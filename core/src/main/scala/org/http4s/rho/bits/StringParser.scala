package org.http4s
package rho.bits

import java.text.SimpleDateFormat
import java.time.Instant
import java.util.{Date, UUID}

import cats.Monad

import scala.util.control.NonFatal

/** Parse values from a `String`
  *
  * @tparam T The result type generated by the parser.
  */
trait StringParser[F[_], M[_], T] extends ResponseGeneratorInstances[F] {

  /** Attempt to parse the `String`. */
  def parse(s: String)(implicit F: Monad[F]): ResultResponse[F, T]

  /** M of the type T */
  def model: Option[M[T]]

  def map[U](f: T => U)(implicit m: M[U]): StringParser[F, M, U] =
    new RMappedParser[F, M, T, U](this, (t: T) => SuccessResponse(f(t)), m)

  def rmap[U](f: T => ResultResponse[F, U])(implicit m: M[U]): StringParser[F, M, U] =
    new RMappedParser[F, M, T, U](this, f, m)

  protected def invalidNumberFormat[A](n: String)(implicit F: Monad[F]): FailureResponse[F] =
    FailureResponse.pure[F] {
      BadRequest.pure(s"Invalid number format: '$n'")
    }
}

class BooleanParser[F[_], M[_]](implicit m: M[Boolean]) extends StringParser[F, M, Boolean] {
  override val model: Some[M[Boolean]] = Some(m)

  override def parse(s: String)(implicit F: Monad[F]): ResultResponse[F, Boolean] = s match {
    case "true" => SuccessResponse(true)
    case "false" => SuccessResponse(false)
    case _ => FailureResponse.pure[F](BadRequest.pure(s"Invalid boolean format: '$s'"))
  }
}

class DoubleParser[F[_], M[_]](implicit m: M[Double]) extends StringParser[F, M, Double] {
  override val model: Some[M[Double]] = Some(m)

  override def parse(s: String)(implicit F: Monad[F]): ResultResponse[F, Double] =
    try SuccessResponse(s.toDouble)
    catch { case _: NumberFormatException => invalidNumberFormat[Double](s) }
}

class FloatParser[F[_], M[_]](implicit m: M[Float]) extends StringParser[F, M, Float] {
  override val model: Some[M[Float]] = Some(m)

  override def parse(s: String)(implicit F: Monad[F]): ResultResponse[F, Float] =
    try SuccessResponse(s.toFloat)
    catch { case _: NumberFormatException => invalidNumberFormat[Float](s) }
}

class IntParser[F[_], M[_]](implicit m: M[Int]) extends StringParser[F, M, Int] {
  override val model: Some[M[Int]] = Some(m)

  override def parse(s: String)(implicit F: Monad[F]): ResultResponse[F, Int] =
    try SuccessResponse(s.toInt)
    catch { case _: NumberFormatException => invalidNumberFormat[Int](s) }
}

class LongParser[F[_], M[_]](implicit m: M[Long]) extends StringParser[F, M, Long] {
  override val model: Some[M[Long]] = Some(m)

  override def parse(s: String)(implicit F: Monad[F]): ResultResponse[F, Long] =
    try SuccessResponse(s.toLong)
    catch { case _: NumberFormatException => invalidNumberFormat[Long](s) }
}

class ShortParser[F[_], M[_]](implicit m: M[Short]) extends StringParser[F, M, Short] {
  override val model: Some[M[Short]] = Some(m)

  override def parse(s: String)(implicit F: Monad[F]): ResultResponse[F, Short] =
    try SuccessResponse(s.toShort)
    catch { case _: NumberFormatException => invalidNumberFormat[Short](s) }
}

class DateParser[F[_], M[_]](implicit m: M[Date]) extends StringParser[F, M, Date] {
  override val model = Some(m)

  override def parse(s: String)(implicit F: Monad[F]): ResultResponse[F, Date] =
    try {
      val df = new SimpleDateFormat("yyyy-MM-dd")
      SuccessResponse(df.parse(s))
    } catch {
      case NonFatal(_) =>
        FailureResponse.pure[F] {
          BadRequest.pure(s"Invalid date format, should be 'yyyy-MM-dd': $s")
        }
    }
}

class InstantParser[F[_], M[_]](implicit m: M[Instant]) extends StringParser[F, M, Instant] {
  override val model = Some(m)

  override def parse(s: String)(implicit F: Monad[F]): ResultResponse[F, Instant] =
    try SuccessResponse(Instant.parse(s))
    catch {
      case NonFatal(_) =>
        FailureResponse.pure[F] {
          BadRequest.pure(s"Invalid instant format, should be in 'yyyy-MM-ddThh:mm:ssZ' format: $s")
        }
    }
}

class UUIDParser[F[_], M[_]](implicit m: M[UUID]) extends StringParser[F, M, UUID] {
  override val model = Some(m)

  override def parse(s: String)(implicit F: Monad[F]): ResultResponse[F, UUID] =
    try SuccessResponse(UUID.fromString(s))
    catch {
      case NonFatal(_) =>
        FailureResponse.pure[F] {
          BadRequest.pure(s"Invalid uuid format: $s")
        }
    }
}

private class RMappedParser[F[_], M[T], T, U](
    base: StringParser[F, M, T],
    f: T => ResultResponse[F, U],
    ttu: M[U])
    extends StringParser[F, M, U] {
  override def model: Option[M[U]] = Some(ttu)

  override def parse(s: String)(implicit F: Monad[F]): ResultResponse[F, U] =
    base.parse(s).flatMap(f)
}

object StringParser {

  ////////////////////// Default parsers //////////////////////////////

  implicit def booleanParser[F[_], M[_]](implicit m: M[Boolean]): BooleanParser[F, M] = new BooleanParser[F, M]()
  implicit def doubleParser[F[_], M[_]](implicit m: M[Double]): DoubleParser[F, M] = new DoubleParser[F, M]()
  implicit def floatParser[F[_], M[_]](implicit m: M[Float]): FloatParser[F, M] = new FloatParser[F, M]()
  implicit def intParser[F[_], M[_]](implicit m: M[Int]): IntParser[F, M] = new IntParser[F, M]()
  implicit def longParser[F[_], M[_]](implicit m: M[Long]): LongParser[F, M] = new LongParser[F, M]()
  implicit def shortParser[F[_], M[_]](implicit m: M[Short]): ShortParser[F, M] = new ShortParser[F, M]()
  implicit def dateParser[F[_], M[_]](implicit m: M[Date]): DateParser[F, M] = new DateParser[F, M]()
  implicit def instantParser[F[_], M[_]](implicit m: M[Instant]): InstantParser[F, M] = new InstantParser[F, M]()
  implicit def uuidParser[F[_], M[_]](implicit m: M[UUID]): UUIDParser[F, M] = new UUIDParser[F, M]()

  implicit def strParser[F[_], M[_]](implicit m: M[String]): StringParser[F, M, String] = new StringParser[F, M, String] {

    override val model: Some[M[String]] = Some(m)

    override def parse(s: String)(implicit F: Monad[F]): ResultResponse[F, String] =
      SuccessResponse(s)
  }
}
